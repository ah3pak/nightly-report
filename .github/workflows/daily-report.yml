name: Daily Telegram Report (Multi-source, resilient)

on:
  schedule:
    - cron: "30 17 * * *"  # Ø§Ø¬Ø±Ø§ Ù‡Ø± Ø±ÙˆØ² Ø³Ø§Ø¹Øª 17:30 UTC â‰ˆ 21:00 Tehran
  workflow_dispatch: {}

jobs:
  send:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 jdatetime

      - name: Download previous values artifact (if exists)
        uses: actions/download-artifact@v4
        with:
          name: last-values
          path: prev
        continue-on-error: true

      - name: Build aggregated message (multi-source + fallback)
        id: build
        run: |
          python3 - <<'PY'
          import requests, re, json, os, datetime, jdatetime
          from bs4 import BeautifulSoup

          def first_number_from_text(s):
              if not s:
                  return None
              s2 = s.replace(',', '')
              m = re.search(r'(\d{1,3}(?:\d{3})*(?:\.\d+)?|\d+(?:\.\d+)?)', s2)
              if m:
                  try:
                      return float(m.group(1))
                  except:
                      return None
              return None

          def try_get_text_from_url(url):
              try:
                  r = requests.get(url, timeout=10, headers={"User-Agent":"Mozilla/5.0"})
                  r.raise_for_status()
                  return r.text
              except:
                  return None

          prev_values = {}
          prev_path = './prev/last-values.json'
          if os.path.exists(prev_path):
              try:
                  with open(prev_path, 'r', encoding='utf-8') as f:
                      prev_values = json.load(f)
              except:
                  prev_values = {}

          # Time
          now_teh = datetime.datetime.utcnow() + datetime.timedelta(hours=3, minutes=30)
          j_now = jdatetime.datetime.fromgregorian(datetime=now_teh)
          weekday_map = ["Ø¯ÙˆØ´Ù†Ø¨Ù‡","Ø³Ù‡â€ŒØ´Ù†Ø¨Ù‡","Ú†Ù‡Ø§Ø±Ø´Ù†Ø¨Ù‡","Ù¾Ù†Ø¬â€ŒØ´Ù†Ø¨Ù‡","Ø¬Ù…Ø¹Ù‡","Ø´Ù†Ø¨Ù‡","ÛŒÚ©â€ŒØ´Ù†Ø¨Ù‡"]
          weekday = weekday_map[j_now.weekday()]
          jalali_date = f"{weekday} {j_now.day} {j_now.j_months_fa[j_now.month-1]} {j_now.year}"
          greg_date = now_teh.strftime("%d %B %Y â€“ Ø³Ø§Ø¹Øª %H:%M")

          # Preferred sources
          tgju_map = {
              "gold_18": "https://www.tgju.org/chart-summary/geram18",
              "sekee": "https://www.tgju.org/chart-summary/sekee",
              "nim": "https://www.tgju.org/chart-summary/sekne-nim",
              "rob": "https://www.tgju.org/chart-summary/sekne-rob",
              "dollar": "https://www.tgju.org/chart-summary/price_dollar_rl",
              "euro": "https://www.tgju.org/chart-summary/price_eur"
          }

          fallback_html_urls = [
              # add your preferred fallback pages here (examples)
              "https://tradersarena.ir/industries/gold-funds",
              "https://talasea.ir",
              "https://goldnewsiran.ir"
          ]

          coingecko_map = {
              "BTC": "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd",
              "ETH": "https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd",
              "SOL": "https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd",
              "BNB": "https://api.coingecko.com/api/v3/simple/price?ids=binancecoin&vs_currencies=usd"
          }

          nobitex_pairs = {
              "tether": "https://api.nobitex.ir/market/stats?symbol=usdt-rls"
          }

          results = {}

          def fetch_tgju_value(url):
              try:
                  r = requests.get(url, timeout=10)
                  r.raise_for_status()
                  j = r.json()
                  cur = j.get('current') or {}
                  p = cur.get('p')
                  if p is None:
                      p = j.get('p')
                  return p
              except:
                  return None

          def fetch_from_fallback_pages():
              for url in fallback_html_urls:
                  txt = try_get_text_from_url(url)
                  if not txt:
                      continue
                  soup = BeautifulSoup(txt, 'html.parser')
                  text = soup.get_text(separator=' ')
                  v = first_number_from_text(text)
                  if v is not None:
                      return v
              return None

          # Gold and fiat
          g = fetch_tgju_value(tgju_map['gold_18'])
          if g:
              try:
                  results['gold_18'] = int(float(str(g).replace(',', '')))
              except:
                  results['gold_18'] = None
          else:
              fb = fetch_from_fallback_pages()
              results['gold_18'] = int(fb) if fb else prev_values.get('gold_18')

          for key in ['sekee','nim','rob','dollar','euro']:
              try:
                  val = fetch_tgju_value(tgju_map.get(key))
                  if val:
                      results[key] = int(float(str(val).replace(',', '')))
                  else:
                      results[key] = prev_values.get(key)
              except:
                  results[key] = prev_values.get(key)

          # Crypto USD via CoinGecko
          crypto_usd = {}
          for k,u in coingecko_map.items():
              try:
                  r = requests.get(u, timeout=10)
                  r.raise_for_status()
                  j = r.json()
                  if 'bitcoin' in j:
                      crypto_usd['BTC'] = j['bitcoin']['usd']
                  if 'ethereum' in j:
                      crypto_usd['ETH'] = j['ethereum']['usd']
                  if 'solana' in j:
                      crypto_usd['SOL'] = j['solana']['usd']
                  if 'binancecoin' in j:
                      crypto_usd['BNB'] = j['binancecoin']['usd']
              except:
                  pass

          # Nobitex USDT->rial for conversion (fallback)
          t_usdt = None
          try:
              r = requests.get(nobitex_pairs['tether'], timeout=10)
              if r.status_code == 200:
                  j = r.json()
                  stats = j.get('stats', {})
                  if 'usdt-rls' in stats:
                      t_usdt = float(stats['usdt-rls'].get('latest') or 0)
          except:
              t_usdt = None

          # combine crypto
          for s in ['BTC','ETH','SOL','BNB']:
              usd = crypto_usd.get(s) or prev_values.get(f"{s}_usd")
              if usd:
                  results[f"{s}_usd"] = usd
                  if t_usdt:
                      try:
                          results[f"{s}_toman"] = int(float(usd) * float(t_usdt))
                      except:
                          results[f"{s}_toman"] = prev_values.get(f"{s}_toman")
              else:
                  results[f"{s}_usd"] = prev_values.get(f"{s}_usd")
                  results[f"{s}_toman"] = prev_values.get(f"{s}_toman")

          # Save last-values.json
          out = {k: v for k, v in results.items()}
          out['_ts'] = now_teh.strftime("%Y-%m-%d %H:%M:%S")
          with open('last-values.json', 'w', encoding='utf-8') as f:
              json.dump(out, f, ensure_ascii=False, indent=2)

          def fmt(v):
              try:
                  return f"{int(v):,}"
              except:
                  return "â€”"

          def pick(key):
              return out.get(key) or prev_values.get(key) or None

          gold_display = fmt(pick('gold_18'))
          sekee_display = fmt(pick('sekee'))
          nim_display = fmt(pick('nim'))
          rob_display = fmt(pick('rob'))
          dollar_display = fmt(pick('dollar'))
          euro_display = fmt(pick('euro'))

          btc_usd = pick('BTC_usd') or pick('BTC_usd')
          btc_usd_display = f"{btc_usd:,.0f}" if isinstance(btc_usd, (int, float)) else "â€”"

          eth_usd = pick('ETH_usd')
          eth_display = f"{eth_usd:,.0f}" if isinstance(eth_usd, (int, float)) else "â€”"

          sol_display = f"{pick('SOL_usd'):,}" if isinstance(pick('SOL_usd'), (int, float)) else "â€”"

          # approximate gram (if gold available)
          gram_display = "â€”"
          try:
              if out.get('gold_18'):
                  gram_display = f"{int(out.get('gold_18') * 1.56):,}"
              elif prev_values.get('gold_18'):
                  gram_display = f"{int(prev_values.get('gold_18') * 1.56):,}"
          except:
              gram_display = "â€”"

          dynamic_text = f"""ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ² Ø¨Ø§Ø²Ø§Ø± Ø·Ù„Ø§ØŒ Ø§Ø±Ø² Ùˆ Ø±Ù…Ø²Ø§Ø±Ø²Ù‡Ø§
ğŸ—“ï¸ {jalali_date} | {greg_date}

ğŸŸ¡ Ø¨Ø§Ø²Ø§Ø± Ø·Ù„Ø§
Ø·Ù„Ø§ÛŒ Û±Û¸ Ø¹ÛŒØ§Ø± Ø§Ù…Ø±ÙˆØ² Ø¨Ø§ Ø±Ø´Ø¯ Û°.Û¸Û¶Ùª Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØµØ¹ÙˆØ¯ÛŒ Ø´Ø¯ Ùˆ Ø¨Ù‡ {gold_display} ØªÙˆÙ…Ø§Ù† Ø±Ø³ÛŒØ¯.
Ù‚ÛŒÙ…Øª Ø§ÙˆÙ†Ø³ Ø¬Ù‡Ø§Ù†ÛŒ Ù‡Ù… ØªØ§ Û´,Û±Û³Û².Û¶Û´ Ø¯Ù„Ø§Ø± Ø¨Ø§Ù„Ø§ Ø±ÙØª Ùˆ Ø³Ú©Ù‡â€ŒÙ‡Ø§ Ù‡Ù… Ú©Ù…ÛŒ Ø§ÙØ²Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª Ø¯Ø§Ø´ØªÙ†Ø¯:
ğŸ”¹ Ø³Ú©Ù‡ Ø§Ù…Ø§Ù…ÛŒ: {sekee_display} ØªÙˆÙ…Ø§Ù†
ğŸ”¹ Ù†ÛŒÙ…â€ŒØ³Ú©Ù‡: {nim_display} ØªÙˆÙ…Ø§Ù†
ğŸ”¹ Ø±Ø¨Ø¹â€ŒØ³Ú©Ù‡: {rob_display} ØªÙˆÙ…Ø§Ù†
ğŸ”¹ Ø³Ú©Ù‡ Ú¯Ø±Ù…ÛŒ: {gram_display} ØªÙˆÙ…Ø§Ù†
Ø¯Ø± Ø¨ÙˆØ±Ø³ØŒ ØµÙ†Ø¯ÙˆÙ‚â€ŒÙ‡Ø§ÛŒ Ø·Ù„Ø§ Ù…Ø«Ù„ Â«Ø²Ø±Ø§ÙØ²Ø§Â» Ù‡Ù… Ø±ÙˆØ² Ù…Ø«Ø¨ØªÛŒ Ø¯Ø§Ø´ØªÙ†Ø¯ Ùˆ Ø­Ø¯ÙˆØ¯ Û°.Û¹Û±Ùª Ø³ÙˆØ¯ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø«Ø¨Øª Ú©Ø±Ø¯Ù†Ø¯.

ğŸ’µ Ø¨Ø§Ø²Ø§Ø± Ø§Ø±Ø²
Ø¨Ø§Ø²Ø§Ø± Ø§Ø±Ø² Ù‡Ù… Ø§Ù…Ø±ÙˆØ² Ù¾Ø±ØªØ­Ø±Ú© Ø¨ÙˆØ¯Ø› Ø¯Ù„Ø§Ø± Ø¨Ø§ Ø±Ø´Ø¯ Û±.Û³Û¸Ùª Ø¨Ù‡ {dollar_display} ØªÙˆÙ…Ø§Ù† Ø±Ø³ÛŒØ¯.
ÛŒÙˆØ±Ùˆ Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ {euro_display} ØªÙˆÙ…Ø§Ù† (+Û±.Û³ÛµÙª)ØŒ Ø¯Ø±Ù‡Ù… Ø§Ù…Ø§Ø±Ø§Øª Û²Û¹,Û¸Û¸Û² ØªÙˆÙ…Ø§Ù† (+Û±.Û³Û·Ùª) Ùˆ Ù„ÛŒØ± ØªØ±Ú©ÛŒÙ‡ Û²,Û¶Û²Û° ØªÙˆÙ…Ø§Ù† (+Û±.ÛµÛ³Ùª) Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø´Ø¯.
Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ø±Ø² Ù†Ø³Ø¨Øª Ø¨Ù‡ Ø¯ÛŒØ±ÙˆØ² Ø­Ø¯ÙˆØ¯ Û±Û°Ùª Ø¨ÛŒØ´ØªØ± Ø¨ÙˆØ¯ Ú©Ù‡ Ù†Ø´ÙˆÙ† Ù…ÛŒâ€ŒØ¯Ù‡ Ø¨Ø§Ø²Ø§Ø± Ù‡Ù†ÙˆØ² Ø¯Ø± ÙØ§Ø² Ù¾Ø±Ù†ÙˆØ³Ø§Ù†ÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ù‡.

ğŸª™ Ø¨Ø§Ø²Ø§Ø± Ø±Ù…Ø²Ø§Ø±Ø²Ù‡Ø§
Ø¯Ø± Ø¨Ø§Ø²Ø§Ø± Ú©Ø±ÛŒÙ¾ØªÙˆØŒ Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ† Ø¨Ø¹Ø¯ Ø§Ø² Ù†ÙˆØ³Ø§Ù†Ø§Øª Ø´Ø¯ÛŒØ¯ Ø±ÙˆØ² Ú¯Ø°Ø´ØªÙ‡ØŒ Ø¨Ø§ Ø±Ø´Ø¯ Û³Ùª Ø¨Ù‡ {btc_usd_display} Ø¯Ù„Ø§Ø± Ø±Ø³ÛŒØ¯.
Ø§ØªØ±ÛŒÙˆÙ… Ù‡Ù… Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ {eth_display} Ø¯Ù„Ø§Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø´Ø¯. Ø³ÙˆÙ„Ø§Ù†Ø§ Ø¨Ø§ Ø±Ø´Ø¯ ÛµÙª Ùˆ Ø¯ÙˆØ¬â€ŒÚ©ÙˆÛŒÙ† Ø¨Ø§ Û¶Ùª Ø§ÙØ²Ø§ÛŒØ´ Ø¯Ø± ØµØ¯Ø± Ø±Ù…Ø²Ø§Ø±Ø²Ù‡Ø§ÛŒ Ø³Ø¨Ø² Ø§Ù…Ø±ÙˆØ² Ø¨ÙˆØ¯Ù†.
Ø§Ø±Ø²Ø´ Ú©Ù„ Ø¨Ø§Ø²Ø§Ø± Ø±Ù…Ø²Ø§Ø±Ø²Ù‡Ø§ Ø­Ø§Ù„Ø§ Ø­Ø¯ÙˆØ¯ Û².Ûµ ØªØ±ÛŒÙ„ÛŒÙˆÙ† Ø¯Ù„Ø§Ø± Ø¨Ø±Ø¢ÙˆØ±Ø¯ Ù…ÛŒâ€ŒØ´Ù‡.
"""

          footer = """ğŸ’¬ ØªØ±Ø§Ø³Øªâ€ŒÙ…ÛŒ Ø·Ù„Ø§ | Trustme Gold
Ø¬Ø§ÛŒÛŒ Ø¨Ø±Ø§ÛŒ ØªØ¨Ø§Ø¯Ù„ Ù†Ø¸Ø± Ùˆ ØªØ¬Ø±Ø¨Ù‡ ÙˆØ§Ù‚Ø¹ÛŒ Ø¯Ø±Ø¨Ø§Ø±Ù‡ Ø®Ø±ÛŒØ¯ Ùˆ ÙØ±ÙˆØ´ Ø·Ù„Ø§

ğŸŒ Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø·:
https://t.me/trustme_exchange
https://t.me/trustme_prop

ğŸ“© Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§ Ù…Ø§:
@TrustMe_Support
"""

          final_msg = dynamic_text + "\n" + footer

          with open("msg.txt", "w", encoding="utf-8") as f:
              f.write(final_msg)

          print("--- preview ---")
          print(final_msg[:600])
          print("...")

          # expose outputs via files (no set-output)
          PY

      - name: Send to Telegram (single message)
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
            echo "ERROR: TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID not set"
            exit 1
          fi
          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            --data-urlencode "chat_id=${TELEGRAM_CHAT_ID}" \
            --data-urlencode "text@msg.txt" \
            --data-urlencode "parse_mode=HTML" \
            --fail -o response.json || (echo "curl failed, response:"; cat response.json || true; exit 1)
          echo "Telegram response:"
          cat response.json || true

      - name: Upload artifacts (last values + last msg)
        uses: actions/upload-artifact@v4
        with:
          name: last-values
          path: |
            last-values.json
            msg.txt
