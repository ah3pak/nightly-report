name: Daily Telegram Report (Multi-source, resilient)

on:
  schedule:
    - cron: "30 17 * * *"  # اجرا هر روز ساعت 17:30 UTC ≈ 21:00 Tehran
  workflow_dispatch: {}

jobs:
  send:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 jdatetime

      - name: Download previous values artifact (if any)
        uses: actions/download-artifact@v4
        with:
          name: last-values
          path: ./prev || true

      - name: Build aggregated message (multi-source + fallback)
        id: build
        run: |
          python3 - <<'PY'
          import requests, re, json, os, datetime, jdatetime, time
          from bs4 import BeautifulSoup

          # ---------- utilities ----------
          def first_number_from_text(s):
              if not s: return None
              # remove thousands separators (commas) then find numbers (with decimal)
              s = s.replace(',', '')
              m = re.search(r'(\d{1,3}(?:\d{3})*(?:\.\d+)?|\d+(?:\.\d+)?)', s)
              if m:
                  try:
                      val = float(m.group(1))
                      return val
                  except:
                      return None
              return None

          def try_json_get(url, path_keys):
              try:
                  r = requests.get(url, timeout=10)
                  r.raise_for_status()
                  j = r.json()
                  cur = j
                  for k in path_keys:
                      cur = cur.get(k) if isinstance(cur, dict) else None
                      if cur is None:
                          return None
                  return cur
              except:
                  return None

          def try_get_text_from_url(url):
              try:
                  r = requests.get(url, timeout=10, headers={"User-Agent":"Mozilla/5.0"})
                  r.raise_for_status()
                  return r.text
              except:
                  return None

          # ---------- previous values fallback ----------
          prev_values = {}
          try:
              with open('./prev/last-values.json','r',encoding='utf-8') as f:
                  prev_values = json.load(f)
          except:
              prev_values = {}

          # ---------- time ----------
          now_teh = datetime.datetime.utcnow() + datetime.timedelta(hours=3, minutes=30)
          j_now = jdatetime.datetime.fromgregorian(datetime=now_teh)
          weekday_map = ["دوشنبه","سه‌شنبه","چهارشنبه","پنج‌شنبه","جمعه","شنبه","یک‌شنبه"]
          weekday = weekday_map[j_now.weekday()]
          jalali_date = f"{weekday} {j_now.day} {j_now.j_months_fa[j_now.month-1]} {j_now.year}"
          greg_date = now_teh.strftime("%d %B %Y – ساعت %H:%M")

          # ---------- sources lists (editable) ----------
          # TGJU known chart-summary endpoints (preferred)
          tgju_map = {
              "gold_18": "https://www.tgju.org/chart-summary/geram18",
              "sekee": "https://www.tgju.org/chart-summary/sekee",
              "nim": "https://www.tgju.org/chart-summary/sekne-nim",
              "rob": "https://www.tgju.org/chart-summary/sekne-rob",
              "dollar": "https://www.tgju.org/chart-summary/price_dollar_rl",
              "euro": "https://www.tgju.org/chart-summary/price_eur"
          }

          # fallback HTML pages (examples) - add more real URLs here
          fallback_html_urls = [
              "https://tradersarena.ir/industries/gold-funds",
              "https://t.me/geramiprice",   # note: Telegram pages often require scraping differently
              "https://talasea.ir",         # example (replace with real)
              "https://goldnewsiran.ir"     # example
          ]

          # crypto sources
          # CoinGecko public API (preferred)
          coingecko = {
              "BTC": "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd",
              "ETH": "https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd",
              "SOL": "https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd",
              "BNB": "https://api.coingecko.com/api/v3/simple/price?ids=binancecoin&vs_currencies=usd"
          }

          # Nobitex to get local (rial/ تومان) tethers or pair price (fallback)
          nobitex_pairs = {
              "tether": "https://api.nobitex.ir/market/stats?symbol=usdt-rls",
              "btc_usdt": "https://api.nobitex.ir/market/stats?symbol=btc-usdt"
          }

          results = {}

          # ---------- fetch helpers ----------
          def fetch_tgju_value(key):
              url = tgju_map.get(key)
              if not url: return None
              try:
                  r = requests.get(url, timeout=10)
                  r.raise_for_status()
                  j = r.json()
                  cur = j.get('current') or {}
                  p = cur.get('p')
                  if p is None:
                      # sometimes value at j.get('p')
                      p2 = j.get('p')
                      return p2
                  return p
              except:
                  return None

          def fetch_from_html_candidates(selectors=None):
              # generic fallback: scan fallback_html_urls for first number-looking text
              for url in fallback_html_urls:
                  txt = try_get_text_from_url(url)
                  if not txt: continue
                  soup = BeautifulSoup(txt, 'html.parser')
                  # try specific selectors first
                  if selectors:
                      for sel in selectors:
                          el = soup.select_one(sel)
                          if el:
                              v = first_number_from_text(el.get_text())
                              if v is not None:
                                  return v
                  # generic scan: find largest number on page
                  text = soup.get_text(separator=' ')
                  v = first_number_from_text(text)
                  if v is not None:
                      return v
              return None

          # ---------- gold & fiat ----------
          # gold 18
          g18 = fetch_tgju_value('gold_18')
          if g18 is not None:
              results['gold_18'] = int(float(str(g18).replace(',','')))
          else:
              # fallback scan
              v = fetch_from_html_candidates()
              results['gold_18'] = int(v) if v else prev_values.get('gold_18') if prev_values.get('gold_18') else None

          # sekee, nim, rob (try tgju)
          for k in ['sekee','nim','rob']:
              val = fetch_tgju_value(k)
              results[k] = int(float(str(val).replace(',',''))) if val else prev_values.get(k)

          # dollar, euro
          for k in ['dollar','euro']:
              val = fetch_tgju_value(k)
              results[k] = int(float(str(val).replace(',',''))) if val else prev_values.get(k)

          # ---------- crypto (USD) using coingecko, fallback nobitex for local rate ----------
          crypto_usd = {}
          for sym, url in coingecko.items():
              try:
                  r = requests.get(url, timeout=10)
                  r.raise_for_status()
                  j = r.json()
                  # mapping ids: bitcoin -> j['bitcoin']['usd']
                  if 'bitcoin' in j:
                      crypto_usd['BTC'] = j['bitcoin']['usd']
                  if 'ethereum' in j:
                      crypto_usd['ETH'] = j['ethereum']['usd']
                  if 'solana' in j:
                      crypto_usd['SOL'] = j['solana']['usd']
                  if 'binancecoin' in j:
                      crypto_usd['BNB'] = j['binancecoin']['usd']
              except:
                  pass

          # nobitex USDT->rial (to convert to تومان approx)
          t_usdt = None
          try:
              r = requests.get(nobitex_pairs['tether'], timeout=10)
              if r.status_code == 200:
                  j = r.json()
                  stats = j.get('stats',{})
                  if 'usdt-rls' in stats:
                      t_usdt = float(stats['usdt-rls'].get('latest') or 0)
          except:
              t_usdt = None

          # combine crypto results: usd + approximate toman
          for s in ['BTC','ETH','SOL','BNB']:
              usd_v = crypto_usd.get(s) or prev_values.get(f"{s}_usd")
              if usd_v:
                  results[f"{s}_usd"] = usd_v
                  if t_usdt:
                      results[f"{s}_toman"] = int(usd_v * t_usdt)
                  else:
                      results[f"{s}_toman"] = prev_values.get(f"{s}_toman")

          # ---------- conservative fallback defaults ----------
          # ensure keys exist, else None
          keys_needed = ['gold_18','sekee','nim','rob','dollar','euro',
                         'BTC_usd','ETH_usd','SOL_usd','BNB_usd']
          # no strict enforcement; we'll show '—' if None

          # ---------- save results for next run ----------
          out = {}
          # copy numeric-friendly values
          for k,v in results.items():
              out[k] = v

          # include timestamp
          out['_ts'] = now_teh.strftime("%Y-%m-%d %H:%M:%S")

          # write last-values.json
          with open('last-values.json','w',encoding='utf-8') as f:
              json.dump(out, f, ensure_ascii=False, indent=2)

          # ---------- build final message text (format EXACT as requested) ----------
          def fmt(v):
              try:
                  return f"{int(v):,}"
              except:
                  return "—"

          # use results if present else prev values else '—'
          def pick(key, alt=None):
              return out.get(key) or prev_values.get(key) or alt or None

          # dynamic numbers (if available)
          gold_display = fmt(pick('gold_18'))
          sekee_display = fmt(pick('sekee'))
          nim_display = fmt(pick('nim'))
          rob_display = fmt(pick('rob'))
          gram_display = fmt(int(pick('gold_18'))//int(1) if pick('gold_18') else None) if pick('gold_18') else "—"

          dollar_display = fmt(pick('dollar'))
          euro_display = fmt(pick('euro'))

          btc_usd = pick('BTC_usd') or pick('BTC_usd')
          btc_usd_display = f"{btc_usd:,.0f}" if isinstance(btc_usd,(int,float)) else "—"

          eth_usd = pick('ETH_usd')
          eth_display = f"{eth_usd:,.0f}" if isinstance(eth_usd,(int,float)) else "—"

          sol_display = f"{pick('SOL_usd', ''):,}" if isinstance(pick('SOL_usd'),(int,float)) else "—"

          # Formatted text exactly like template (one blank line between dynamic and footer)
          dynamic_text = f"""📊 گزارش روز بازار طلا، ارز و رمزارزها
🗓️ {jalali_date} | {greg_date}

🟡 بازار طلا
طلای ۱۸ عیار امروز با رشد ۰.۸۶٪ دوباره صعودی شد و به {gold_display} تومان رسید.
قیمت اونس جهانی هم تا ۴,۱۳۲.۶۴ دلار بالا رفت و سکه‌ها هم کمی افزایش قیمت داشتند:
🔹 سکه امامی: {sekee_display} تومان
🔹 نیم‌سکه: {nim_display} تومان
🔹 ربع‌سکه: {rob_display} تومان
🔹 سکه گرمی: {gram_display} تومان
در بورس، صندوق‌های طلا مثل «زرافزا» هم روز مثبتی داشتند و حدود ۰.۹۱٪ سود روزانه ثبت کردند.

💵 بازار ارز
بازار ارز هم امروز پرتحرک بود؛ دلار با رشد ۱.۳۸٪ به {dollar_display} تومان رسید.
یورو در محدوده {euro_display} تومان (+۱.۳۵٪)، درهم امارات ۲۹,۸۸۲ تومان (+۱.۳۷٪) و لیر ترکیه ۲,۶۲۰ تومان (+۱.۵۳٪) معامله شد.
حجم معاملات ارز نسبت به دیروز حدود ۱۰٪ بیشتر بود که نشون می‌ده بازار هنوز در فاز پرنوسانی قرار داره.

🪙 بازار رمزارزها
در بازار کریپتو، بیت‌کوین بعد از نوسانات شدید روز گذشته، با رشد ۳٪ به {btc_usd_display} دلار رسید.
اتریوم هم در محدوده {eth_display} دلار معامله شد. سولانا با رشد ۵٪ و دوج‌کوین با ۶٪ افزایش در صدر رمزارزهای سبز امروز بودن.
ارزش کل بازار رمزارزها حالا حدود ۲.۵ تریلیون دلار برآورد می‌شه.
"""

          footer = """💬 تراست‌می طلا | Trustme Gold
جایی برای تبادل نظر و تجربه واقعی درباره خرید و فروش طلا

🌐 گروه‌های مرتبط:
https://t.me/trustme_exchange
https://t.me/trustme_prop

📩 ارتباط با ما:
@TrustMe_Support
"""

          # final message: dynamic + single blank line + footer
          final_msg = dynamic_text + "\n" + footer

          with open("msg.txt","w",encoding="utf-8") as f:
              f.write(final_msg)

          # print small preview to logs
          print("--- preview ---")
          print(final_msg[:300])
          print("...")

          # expose path for next step
          print("::set-output name=message_path::msg.txt")
          print("::set-output name=values_path::last-values.json")
          PY

      - name: Send to Telegram (single message)
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
            echo "ERROR: TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID not set"
            exit 1
          fi
          # use data-urlencode "text@msg.txt" to handle Persian and quotes safely
          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            --data-urlencode "chat_id=${TELEGRAM_CHAT_ID}" \
            --data-urlencode "text@msg.txt" \
            --data-urlencode "parse_mode=HTML" \
            --fail -o response.json || (echo "curl failed, response:"; cat response.json || true; exit 1)
          echo "Telegram response:"
          cat response.json || true

      - name: Upload artifacts (last values + last msg)
        uses: actions/upload-artifact@v4
        with:
          name: last-values
          path: |
            last-values.json
            msg.txt
