name: Daily Telegram Report (Multi-source, resilient)

on:
  schedule:
    - cron: "30 17 * * *"  # Ø§Ø¬Ø±Ø§ Ù‡Ø± Ø±ÙˆØ² Ø³Ø§Ø¹Øª 17:30 UTC â‰ˆ 21:00 Tehran
  workflow_dispatch: {}

jobs:
  send:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 jdatetime

      - name: Download previous values artifact (if any)
        uses: actions/download-artifact@v4
        with:
          name: last-values
          path: ./prev || true

      - name: Build aggregated message (multi-source + fallback)
        id: build
        run: |
          python3 - <<'PY'
          import requests, re, json, os, datetime, jdatetime, time
          from bs4 import BeautifulSoup

          # ---------- utilities ----------
          def first_number_from_text(s):
              if not s: return None
              # remove thousands separators (commas) then find numbers (with decimal)
              s = s.replace(',', '')
              m = re.search(r'(\d{1,3}(?:\d{3})*(?:\.\d+)?|\d+(?:\.\d+)?)', s)
              if m:
                  try:
                      val = float(m.group(1))
                      return val
                  except:
                      return None
              return None

          def try_json_get(url, path_keys):
              try:
                  r = requests.get(url, timeout=10)
                  r.raise_for_status()
                  j = r.json()
                  cur = j
                  for k in path_keys:
                      cur = cur.get(k) if isinstance(cur, dict) else None
                      if cur is None:
                          return None
                  return cur
              except:
                  return None

          def try_get_text_from_url(url):
              try:
                  r = requests.get(url, timeout=10, headers={"User-Agent":"Mozilla/5.0"})
                  r.raise_for_status()
                  return r.text
              except:
                  return None

          # ---------- previous values fallback ----------
          prev_values = {}
          try:
              with open('./prev/last-values.json','r',encoding='utf-8') as f:
                  prev_values = json.load(f)
          except:
              prev_values = {}

          # ---------- time ----------
          now_teh = datetime.datetime.utcnow() + datetime.timedelta(hours=3, minutes=30)
          j_now = jdatetime.datetime.fromgregorian(datetime=now_teh)
          weekday_map = ["Ø¯ÙˆØ´Ù†Ø¨Ù‡","Ø³Ù‡â€ŒØ´Ù†Ø¨Ù‡","Ú†Ù‡Ø§Ø±Ø´Ù†Ø¨Ù‡","Ù¾Ù†Ø¬â€ŒØ´Ù†Ø¨Ù‡","Ø¬Ù…Ø¹Ù‡","Ø´Ù†Ø¨Ù‡","ÛŒÚ©â€ŒØ´Ù†Ø¨Ù‡"]
          weekday = weekday_map[j_now.weekday()]
          jalali_date = f"{weekday} {j_now.day} {j_now.j_months_fa[j_now.month-1]} {j_now.year}"
          greg_date = now_teh.strftime("%d %B %Y â€“ Ø³Ø§Ø¹Øª %H:%M")

          # ---------- sources lists (editable) ----------
          # TGJU known chart-summary endpoints (preferred)
          tgju_map = {
              "gold_18": "https://www.tgju.org/chart-summary/geram18",
              "sekee": "https://www.tgju.org/chart-summary/sekee",
              "nim": "https://www.tgju.org/chart-summary/sekne-nim",
              "rob": "https://www.tgju.org/chart-summary/sekne-rob",
              "dollar": "https://www.tgju.org/chart-summary/price_dollar_rl",
              "euro": "https://www.tgju.org/chart-summary/price_eur"
          }

          # fallback HTML pages (examples) - add more real URLs here
          fallback_html_urls = [
              "https://tradersarena.ir/industries/gold-funds",
              "https://t.me/geramiprice",   # note: Telegram pages often require scraping differently
              "https://talasea.ir",         # example (replace with real)
              "https://goldnewsiran.ir"     # example
          ]

          # crypto sources
          # CoinGecko public API (preferred)
          coingecko = {
              "BTC": "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd",
              "ETH": "https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd",
              "SOL": "https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd",
              "BNB": "https://api.coingecko.com/api/v3/simple/price?ids=binancecoin&vs_currencies=usd"
          }

          # Nobitex to get local (rial/ ØªÙˆÙ…Ø§Ù†) tethers or pair price (fallback)
          nobitex_pairs = {
              "tether": "https://api.nobitex.ir/market/stats?symbol=usdt-rls",
              "btc_usdt": "https://api.nobitex.ir/market/stats?symbol=btc-usdt"
          }

          results = {}

          # ---------- fetch helpers ----------
          def fetch_tgju_value(key):
              url = tgju_map.get(key)
              if not url: return None
              try:
                  r = requests.get(url, timeout=10)
                  r.raise_for_status()
                  j = r.json()
                  cur = j.get('current') or {}
                  p = cur.get('p')
                  if p is None:
                      # sometimes value at j.get('p')
                      p2 = j.get('p')
                      return p2
                  return p
              except:
                  return None

          def fetch_from_html_candidates(selectors=None):
              # generic fallback: scan fallback_html_urls for first number-looking text
              for url in fallback_html_urls:
                  txt = try_get_text_from_url(url)
                  if not txt: continue
                  soup = BeautifulSoup(txt, 'html.parser')
                  # try specific selectors first
                  if selectors:
                      for sel in selectors:
                          el = soup.select_one(sel)
                          if el:
                              v = first_number_from_text(el.get_text())
                              if v is not None:
                                  return v
                  # generic scan: find largest number on page
                  text = soup.get_text(separator=' ')
                  v = first_number_from_text(text)
                  if v is not None:
                      return v
              return None

          # ---------- gold & fiat ----------
          # gold 18
          g18 = fetch_tgju_value('gold_18')
          if g18 is not None:
              results['gold_18'] = int(float(str(g18).replace(',','')))
          else:
              # fallback scan
              v = fetch_from_html_candidates()
              results['gold_18'] = int(v) if v else prev_values.get('gold_18') if prev_values.get('gold_18') else None

          # sekee, nim, rob (try tgju)
          for k in ['sekee','nim','rob']:
              val = fetch_tgju_value(k)
              results[k] = int(float(str(val).replace(',',''))) if val else prev_values.get(k)

          # dollar, euro
          for k in ['dollar','euro']:
              val = fetch_tgju_value(k)
              results[k] = int(float(str(val).replace(',',''))) if val else prev_values.get(k)

          # ---------- crypto (USD) using coingecko, fallback nobitex for local rate ----------
          crypto_usd = {}
          for sym, url in coingecko.items():
              try:
                  r = requests.get(url, timeout=10)
                  r.raise_for_status()
                  j = r.json()
                  # mapping ids: bitcoin -> j['bitcoin']['usd']
                  if 'bitcoin' in j:
                      crypto_usd['BTC'] = j['bitcoin']['usd']
                  if 'ethereum' in j:
                      crypto_usd['ETH'] = j['ethereum']['usd']
                  if 'solana' in j:
                      crypto_usd['SOL'] = j['solana']['usd']
                  if 'binancecoin' in j:
                      crypto_usd['BNB'] = j['binancecoin']['usd']
              except:
                  pass

          # nobitex USDT->rial (to convert to ØªÙˆÙ…Ø§Ù† approx)
          t_usdt = None
          try:
              r = requests.get(nobitex_pairs['tether'], timeout=10)
              if r.status_code == 200:
                  j = r.json()
                  stats = j.get('stats',{})
                  if 'usdt-rls' in stats:
                      t_usdt = float(stats['usdt-rls'].get('latest') or 0)
          except:
              t_usdt = None

          # combine crypto results: usd + approximate toman
          for s in ['BTC','ETH','SOL','BNB']:
              usd_v = crypto_usd.get(s) or prev_values.get(f"{s}_usd")
              if usd_v:
                  results[f"{s}_usd"] = usd_v
                  if t_usdt:
                      results[f"{s}_toman"] = int(usd_v * t_usdt)
                  else:
                      results[f"{s}_toman"] = prev_values.get(f"{s}_toman")

          # ---------- conservative fallback defaults ----------
          # ensure keys exist, else None
          keys_needed = ['gold_18','sekee','nim','rob','dollar','euro',
                         'BTC_usd','ETH_usd','SOL_usd','BNB_usd']
          # no strict enforcement; we'll show 'â€”' if None

          # ---------- save results for next run ----------
          out = {}
          # copy numeric-friendly values
          for k,v in results.items():
              out[k] = v

          # include timestamp
          out['_ts'] = now_teh.strftime("%Y-%m-%d %H:%M:%S")

          # write last-values.json
          with open('last-values.json','w',encoding='utf-8') as f:
              json.dump(out, f, ensure_ascii=False, indent=2)

          # ---------- build final message text (format EXACT as requested) ----------
          def fmt(v):
              try:
                  return f"{int(v):,}"
              except:
                  return "â€”"

          # use results if present else prev values else 'â€”'
          def pick(key, alt=None):
              return out.get(key) or prev_values.get(key) or alt or None

          # dynamic numbers (if available)
          gold_display = fmt(pick('gold_18'))
          sekee_display = fmt(pick('sekee'))
          nim_display = fmt(pick('nim'))
          rob_display = fmt(pick('rob'))
          gram_display = fmt(int(pick('gold_18'))//int(1) if pick('gold_18') else None) if pick('gold_18') else "â€”"

          dollar_display = fmt(pick('dollar'))
          euro_display = fmt(pick('euro'))

          btc_usd = pick('BTC_usd') or pick('BTC_usd')
          btc_usd_display = f"{btc_usd:,.0f}" if isinstance(btc_usd,(int,float)) else "â€”"

          eth_usd = pick('ETH_usd')
          eth_display = f"{eth_usd:,.0f}" if isinstance(eth_usd,(int,float)) else "â€”"

          sol_display = f"{pick('SOL_usd', ''):,}" if isinstance(pick('SOL_usd'),(int,float)) else "â€”"

          # Formatted text exactly like template (one blank line between dynamic and footer)
          dynamic_text = f"""ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ² Ø¨Ø§Ø²Ø§Ø± Ø·Ù„Ø§ØŒ Ø§Ø±Ø² Ùˆ Ø±Ù…Ø²Ø§Ø±Ø²Ù‡Ø§
ğŸ—“ï¸ {jalali_date} | {greg_date}

ğŸŸ¡ Ø¨Ø§Ø²Ø§Ø± Ø·Ù„Ø§
Ø·Ù„Ø§ÛŒ Û±Û¸ Ø¹ÛŒØ§Ø± Ø§Ù…Ø±ÙˆØ² Ø¨Ø§ Ø±Ø´Ø¯ Û°.Û¸Û¶Ùª Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØµØ¹ÙˆØ¯ÛŒ Ø´Ø¯ Ùˆ Ø¨Ù‡ {gold_display} ØªÙˆÙ…Ø§Ù† Ø±Ø³ÛŒØ¯.
Ù‚ÛŒÙ…Øª Ø§ÙˆÙ†Ø³ Ø¬Ù‡Ø§Ù†ÛŒ Ù‡Ù… ØªØ§ Û´,Û±Û³Û².Û¶Û´ Ø¯Ù„Ø§Ø± Ø¨Ø§Ù„Ø§ Ø±ÙØª Ùˆ Ø³Ú©Ù‡â€ŒÙ‡Ø§ Ù‡Ù… Ú©Ù…ÛŒ Ø§ÙØ²Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª Ø¯Ø§Ø´ØªÙ†Ø¯:
ğŸ”¹ Ø³Ú©Ù‡ Ø§Ù…Ø§Ù…ÛŒ: {sekee_display} ØªÙˆÙ…Ø§Ù†
ğŸ”¹ Ù†ÛŒÙ…â€ŒØ³Ú©Ù‡: {nim_display} ØªÙˆÙ…Ø§Ù†
ğŸ”¹ Ø±Ø¨Ø¹â€ŒØ³Ú©Ù‡: {rob_display} ØªÙˆÙ…Ø§Ù†
ğŸ”¹ Ø³Ú©Ù‡ Ú¯Ø±Ù…ÛŒ: {gram_display} ØªÙˆÙ…Ø§Ù†
Ø¯Ø± Ø¨ÙˆØ±Ø³ØŒ ØµÙ†Ø¯ÙˆÙ‚â€ŒÙ‡Ø§ÛŒ Ø·Ù„Ø§ Ù…Ø«Ù„ Â«Ø²Ø±Ø§ÙØ²Ø§Â» Ù‡Ù… Ø±ÙˆØ² Ù…Ø«Ø¨ØªÛŒ Ø¯Ø§Ø´ØªÙ†Ø¯ Ùˆ Ø­Ø¯ÙˆØ¯ Û°.Û¹Û±Ùª Ø³ÙˆØ¯ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø«Ø¨Øª Ú©Ø±Ø¯Ù†Ø¯.

ğŸ’µ Ø¨Ø§Ø²Ø§Ø± Ø§Ø±Ø²
Ø¨Ø§Ø²Ø§Ø± Ø§Ø±Ø² Ù‡Ù… Ø§Ù…Ø±ÙˆØ² Ù¾Ø±ØªØ­Ø±Ú© Ø¨ÙˆØ¯Ø› Ø¯Ù„Ø§Ø± Ø¨Ø§ Ø±Ø´Ø¯ Û±.Û³Û¸Ùª Ø¨Ù‡ {dollar_display} ØªÙˆÙ…Ø§Ù† Ø±Ø³ÛŒØ¯.
ÛŒÙˆØ±Ùˆ Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ {euro_display} ØªÙˆÙ…Ø§Ù† (+Û±.Û³ÛµÙª)ØŒ Ø¯Ø±Ù‡Ù… Ø§Ù…Ø§Ø±Ø§Øª Û²Û¹,Û¸Û¸Û² ØªÙˆÙ…Ø§Ù† (+Û±.Û³Û·Ùª) Ùˆ Ù„ÛŒØ± ØªØ±Ú©ÛŒÙ‡ Û²,Û¶Û²Û° ØªÙˆÙ…Ø§Ù† (+Û±.ÛµÛ³Ùª) Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø´Ø¯.
Ø­Ø¬Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ø±Ø² Ù†Ø³Ø¨Øª Ø¨Ù‡ Ø¯ÛŒØ±ÙˆØ² Ø­Ø¯ÙˆØ¯ Û±Û°Ùª Ø¨ÛŒØ´ØªØ± Ø¨ÙˆØ¯ Ú©Ù‡ Ù†Ø´ÙˆÙ† Ù…ÛŒâ€ŒØ¯Ù‡ Ø¨Ø§Ø²Ø§Ø± Ù‡Ù†ÙˆØ² Ø¯Ø± ÙØ§Ø² Ù¾Ø±Ù†ÙˆØ³Ø§Ù†ÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ù‡.

ğŸª™ Ø¨Ø§Ø²Ø§Ø± Ø±Ù…Ø²Ø§Ø±Ø²Ù‡Ø§
Ø¯Ø± Ø¨Ø§Ø²Ø§Ø± Ú©Ø±ÛŒÙ¾ØªÙˆØŒ Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ† Ø¨Ø¹Ø¯ Ø§Ø² Ù†ÙˆØ³Ø§Ù†Ø§Øª Ø´Ø¯ÛŒØ¯ Ø±ÙˆØ² Ú¯Ø°Ø´ØªÙ‡ØŒ Ø¨Ø§ Ø±Ø´Ø¯ Û³Ùª Ø¨Ù‡ {btc_usd_display} Ø¯Ù„Ø§Ø± Ø±Ø³ÛŒØ¯.
Ø§ØªØ±ÛŒÙˆÙ… Ù‡Ù… Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ {eth_display} Ø¯Ù„Ø§Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø´Ø¯. Ø³ÙˆÙ„Ø§Ù†Ø§ Ø¨Ø§ Ø±Ø´Ø¯ ÛµÙª Ùˆ Ø¯ÙˆØ¬â€ŒÚ©ÙˆÛŒÙ† Ø¨Ø§ Û¶Ùª Ø§ÙØ²Ø§ÛŒØ´ Ø¯Ø± ØµØ¯Ø± Ø±Ù…Ø²Ø§Ø±Ø²Ù‡Ø§ÛŒ Ø³Ø¨Ø² Ø§Ù…Ø±ÙˆØ² Ø¨ÙˆØ¯Ù†.
Ø§Ø±Ø²Ø´ Ú©Ù„ Ø¨Ø§Ø²Ø§Ø± Ø±Ù…Ø²Ø§Ø±Ø²Ù‡Ø§ Ø­Ø§Ù„Ø§ Ø­Ø¯ÙˆØ¯ Û².Ûµ ØªØ±ÛŒÙ„ÛŒÙˆÙ† Ø¯Ù„Ø§Ø± Ø¨Ø±Ø¢ÙˆØ±Ø¯ Ù…ÛŒâ€ŒØ´Ù‡.
"""

          footer = """ğŸ’¬ ØªØ±Ø§Ø³Øªâ€ŒÙ…ÛŒ Ø·Ù„Ø§ | Trustme Gold
Ø¬Ø§ÛŒÛŒ Ø¨Ø±Ø§ÛŒ ØªØ¨Ø§Ø¯Ù„ Ù†Ø¸Ø± Ùˆ ØªØ¬Ø±Ø¨Ù‡ ÙˆØ§Ù‚Ø¹ÛŒ Ø¯Ø±Ø¨Ø§Ø±Ù‡ Ø®Ø±ÛŒØ¯ Ùˆ ÙØ±ÙˆØ´ Ø·Ù„Ø§

ğŸŒ Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø·:
https://t.me/trustme_exchange
https://t.me/trustme_prop

ğŸ“© Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§ Ù…Ø§:
@TrustMe_Support
"""

          # final message: dynamic + single blank line + footer
          final_msg = dynamic_text + "\n" + footer

          with open("msg.txt","w",encoding="utf-8") as f:
              f.write(final_msg)

          # print small preview to logs
          print("--- preview ---")
          print(final_msg[:300])
          print("...")

          # expose path for next step
          print("::set-output name=message_path::msg.txt")
          print("::set-output name=values_path::last-values.json")
          PY

      - name: Send to Telegram (single message)
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
            echo "ERROR: TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID not set"
            exit 1
          fi
          # use data-urlencode "text@msg.txt" to handle Persian and quotes safely
          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            --data-urlencode "chat_id=${TELEGRAM_CHAT_ID}" \
            --data-urlencode "text@msg.txt" \
            --data-urlencode "parse_mode=HTML" \
            --fail -o response.json || (echo "curl failed, response:"; cat response.json || true; exit 1)
          echo "Telegram response:"
          cat response.json || true

      - name: Upload artifacts (last values + last msg)
        uses: actions/upload-artifact@v4
        with:
          name: last-values
          path: |
            last-values.json
            msg.txt
